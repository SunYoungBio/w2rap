
import sys
from Bio import SeqIO
import re

# Process a FASTA fie and collapse gaps generated by the SOAP scaffolder where 
# we have the same seqeunce before and after the gap
# To be collapsed, the gap must be <200bp and the perfect overlap is <=199bp

def collapse(before_gap_seq, after_gap_seq, gap_length):
  """ Work out whether to collapse a sequence over a gap """

  # rtn = 0 : don't collapse (default)
  # rtn = 1 : collapse

  rtn = 0

  #print "gap_length=", gap_length

  if int(gap_length) < 200:
    #print "before", before_gap_seq
    #print "after", after_gap_seq

    repeat_start = after_gap_seq[0:30]
    #print "seq to look for before gap",repeat_start

    found_before_gap = before_gap_seq.find(repeat_start)
    if found_before_gap > -1:
      #print "found at",found_before_gap
      repeat_seq_before = before_gap_seq[found_before_gap:]
      #print "before",repeat_seq_before

      repeat_seq_after = after_gap_seq[:len(repeat_seq_before)]
      #print "after",repeat_seq_after

      if repeat_seq_before == repeat_seq_after and len(repeat_seq_before) < 200:
        #print "repeat_length=",len(repeat_seq_before)
        rtn = 1

  return rtn

##### MAIN #####

if len(sys.argv) != 3:
    print "Usage: {0} FASTA_IN FASTA_OUT".format(sys.argv[0])
    sys.exit()

FASTA_IN = sys.argv[1]
FASTA_OUT = sys.argv[2]

seq_count = 0
collapse_count = 0
not_collapse_count = 0

# open output file
fout = open(FASTA_OUT, 'w')

seqiter = SeqIO.parse(open(FASTA_IN), 'fasta')
for seq in seqiter:
  #print "checking", seq.id, "length", len(seq.seq)
  
  seq_count = seq_count + 1
  new_seq = ""
  prev_gap_end = 0

  # find gaps and get start and end co-ords
  p = re.compile("N+")
  for m in p.finditer(str(seq.seq)):
    #print "start=", m.start(), "end=", m.end()
    gap_start = m.start()
    gap_end = m.end()

    #print "first N at", gap_start + 1
    #print "last N at", gap_end

    gap_length = int(gap_end) - int(gap_start)

    # get 200 bases before and after the gap
    before_gap_seq = seq.seq[gap_start - 200:gap_start - 1] 
    after_gap_seq = seq.seq[gap_end:gap_end + 200]
    if collapse(before_gap_seq, after_gap_seq, gap_length) == 1:	# collapse
      # record seq from end of prev gap to start of current gap (which includes the collapsed repeat)
      new_seq = new_seq + seq.seq[prev_gap_end:gap_start]
      collapse_count = collapse_count + 1
    else:	# don\t collapse
      # record seq from end of prev gap to end of current gap
      new_seq = new_seq + seq.seq[prev_gap_end:gap_end]
      not_collapse_count = not_collapse_count + 1

    # record the prev gap end
    prev_gap_end = gap_end 
  
  # add the sequence after the final gap
  new_seq = new_seq + seq.seq[prev_gap_end:]

  # write the new seq to a file
  fout.write(">{0}\n{1}\n".format(seq.id, new_seq))

fout.close

print "DONE\n{0} sequences processed, {1} collapsed, {2} not collapsed".format(seq_count, collapse_count, not_collapse_count)
